解题思路
求方案数，采用动态规划方法来求解。
step1:

确定状态：

可以知道，对于每一个字母，我们可能是用一个数字来解码（1-9），也可能是用两个数字来解码（11 - 26）
由此可以划分出子问题，假设字符串的长度是 N，要求前 N 个字符的解密方式数，需要知道前 N - 1 和前 N - 2 个字符的解密方式数。
确定转移方程

设数字串 S 前 i 个字母解密成字母串有 dp[i]种方式
有两种情况：
第 i 个字母也就是 s[i - 1]可以解码成一个字母 （条件是 s[i]在 1-9 之间，即不能是 0）
第 i - 1 个和第 i 个字母组合起来可以解码成一个字母即 s[i-2]s[i-1] (条件是在范围 10-26 内)
所以列出方程 dp[i] = dp[i-1] | s[i-1]对应一个字母 + dp[i-2] | s[i-2]s[i-1]对应一个字母
初始条件&边界情况

dp[0] = 1 (这里 dp[0]指的是前 0 个字母可以组成的方式数)，因为我们定义的转移方程的含义是设数字串 S 前 i 个数字解密成字母串有 dp[i]种方式,这样是为了计算方便更容易初始化。
边界情况:如果 i = 1, 只看最后一个字母
计算顺序：依次计算 dp[1],dp[2]....dp[N]

代码
```js

// @param {string} s
// @return {number}

  var numDecodings = function (s) {
  if (s.length === 0 || +s[0] === 0) return 0

      const n = s.length
      const dp = new Array(n + 1).fill(0)
      // 初始化
      dp[0] = 1

      for (let i = 1; i <= n; i++) {
          if (s[i - 1] !== '0') {
              dp[i] += dp[i - 1]
          }
           // i = 1即前1个字符的解码方式数，只需看s[0]就行
           // 这也是为什么我们状态方程也定义成前i个数的解码方式数，试想我们dp[i]表示的是坐标i的话，我们的初始化就比较麻烦了，我们初始化就需//         //要算dp[0]和dp[1],dp[1]表示的就是坐标1了，那就是有两个字符了，就需要分情况讨论了。
          if (i >= 2 && s[i - 2] === '1' || s[i - 2] === '2' && +s[i - 1] <= 6) {
              dp[i] += dp[i - 2]
          }

      }
      return dp[n]

};
```
当然我们发现，其实 dp[i]的值只有 dp[i - 1]和 dp[i - 2]相关，所以可以用一个长度为 3 的数组来存状态就行。即滚动数组优化空间方式

代码（滚动数组优化）

```js

// @param {string} s
// @return {number}
  var numDecodings = function (s) {
  if (s.length === 0 || +s[0] === 0) return 0

      const n = s.length
      const dp = new Array(3).fill(0)
      dp[0] = 1

      for (let i = 1; i <= n; i++) {
          dp[i % 3] = 0
          if (s[i - 1] !== '0') {
              dp[i % 3] += dp[(i - 1) % 3]
          }
          if (i >= 2 && s[i - 2] === '1' || s[i - 2] === '2' && +s[i - 1] <= 6) {
              dp[i % 3] += dp[(i - 2) % 3]
          }

      }
      return dp[n % 3]

};
```
